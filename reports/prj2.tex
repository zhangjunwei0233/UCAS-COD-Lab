% 这是中国科学院大学计算机科学与技术专业《计算机组成原理（研讨课）》使用的实验报告 Latex 模板
% 本模板与 2024 年 2 月 Jun-xiong Ji 完成, 更改自由 Shing-Ho Lin 和 Jun-Xiong Ji 于 2022 年 9 月共同完成的基础物理实验模板
% 如有任何问题, 请联系: jijunxoing21@mails.ucas.ac.cn
% This is the LaTeX template for report of Experiment of Computer Organization and Design courses, based on its provided Word template. 
% This template is completed on Febrary 2024, based on the joint collabration of Shing-Ho Lin and Junxiong Ji in September 2022. 
% Adding numerous pictures and equations leads to unsatisfying experience in Word. Therefore LaTeX is better. 
% Feel free to contact me via: jijunxoing21@mails.ucas.ac.cn

\documentclass[11pt]{article}

\usepackage[a4paper]{geometry}
\geometry{left=2.0cm,right=2.0cm,top=2.5cm,bottom=2.5cm}

\usepackage{ctex} % 支持中文的LaTeX宏包
\usepackage{amsmath,amsfonts,graphicx,subfigure,amssymb,bm,amsthm,mathrsfs,mathtools,breqn} % 数学公式和符号的宏包集合
\usepackage{algorithm,algorithmicx} % 算法和伪代码
\usepackage[noend]{algpseudocode} % 算法和伪代码
\usepackage{fancyhdr} % 自定义页眉页脚
\usepackage[framemethod=TikZ]{mdframed} % 创建带边框的框架
\usepackage{fontspec} % 字体设置
\usepackage{adjustbox} % 调整盒子大小
\usepackage{fontsize} % 设置字体大小
\usepackage{tikz,xcolor} % 绘制图形和使用颜色
\usepackage{multicol} % 多栏排版
\usepackage{multirow} % 表格中合并单元格
\usepackage{pdfpages} % 插入PDF文件
\usepackage{listings} % 在文档中插入源代码
\usepackage{wrapfig} % 文字绕排图片
\usepackage{bigstrut,multirow,rotating} % 支持在表格中使用特殊命令
\usepackage{booktabs} % 创建美观的表格
\usepackage{circuitikz} % 绘制电路图
\usepackage{zhnumber} % 中文序号（用于标题）
\usepackage{tabularx} % 表格折行

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  framerule=1pt,
  rulecolor=\color{gray!35},
  backgroundcolor=\color{gray!5},
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% 轻松引用, 可以用\cref{}指令直接引用, 自动加前缀. 
% 例: 图片label为fig:1
% \cref{fig:1} => Figure.1
% \ref{fig:1}  => 1
\usepackage[capitalize]{cleveref}
% \crefname{section}{Sec.}{Secs.}
\Crefname{section}{Section}{Sections}
\Crefname{table}{Table}{Tables}
\crefname{table}{Table.}{Tabs.}

% \setmainfont{Palatino Linotype.ttf}
% \setCJKmainfont{SimHei.ttf}
% \setCJKsansfont{Songti.ttf}
% \setCJKmonofont{SimSun.ttf}
\punctstyle{kaiming}
% 偏好的几个字体, 可以根据需要自行加入字体ttf文件并调用

\renewcommand{\emph}[1]{\begin{kaishu}#1\end{kaishu}}

% 对 section 等环境的序号使用中文
\renewcommand \thesection{\zhnum{section}、}
\renewcommand \thesubsection{\arabic{section}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%改这里可以修改实验报告表头的信息
\newcommand{\name}{张钧玮}
\newcommand{\studentNum}{2023K8009908003}
\newcommand{\major}{计算机科学与技术}
\newcommand{\labNum}{2}
\newcommand{\labName}{简单功能型处理器设计——基于MIPS32位指令集}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\input{tex_file/head.tex}

\section{逻辑电路结构与仿真波形的截图及说明}

\noindent
$\bullet$
\textbf{移位运算部件设计}

\begin{figure}[H]
  \centering
  \includegraphics[width=10cm]{fig/shifter_code.png}
  \caption{移位运算部件代码}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{fig/shifter_circuit.png}
  \caption{移位运算部件电路示意图}
\end{figure}

关键设计点说明：

实现\textbf{桶型移位器}，相比与传统的移位器，可以在一个时钟周期内移动任意的位数，提高了运算的效率。
实现思路如下：

1. 只需要支持移动1位，2位，4位...，便可以根据这些层级的组合移动出任意的位数

2. 这样的如何正是要移动的位数的二进制编码。因此直接分离移动位数输入的每一位便可以得到对应每一层级的控制信号

\vspace{1ex}

\noindent
$\bullet$
\textbf{CPU设计}

运行客户程序需要实现基础的45条值令。首先分析各个值令对应的译码信号整合如下：

\begin{figure}[H]
  \centering
  \includegraphics[width=14cm]{fig/decode_table.png}
  \caption{值令译码表}
\end{figure}

其中短横线-代表随意取值，即取值不影响值令的执行。原因分析见第二部分——译码逻辑的简化一节。对应的整体电路大致如图\ref{fig:CPU_circuit}所示：

\begin{figure}[H]
  \centering
  \includegraphics[width=6cm]{fig/CPU_circuit.png}
  \caption{CPU电路示意图}
  \label{fig:CPU_circuit}
\end{figure}

CPU的设计主要分为几个部分：各个模块的实例化，译码逻辑部分，各个实例化的模块与译码信号之间的连接，以及更新PC的时序逻辑的设计。下面分部分介绍：

1. \textbf{模块的实例化}

\begin{figure}[H]
  \centering
  \includegraphics[width=10cm]{fig/CPU_instantiation.png}
  \caption{各个模块的实例化}
  \label{fig:CPU_instantiation}
\end{figure}

实例化的代码见图\ref{fig:CPU_instantiation}。需要实例化的部件包括：组合逻辑的shifter, ALU和寄存器regFile,PC。（内存在CPU的外部定义）

2. \textbf{译码逻辑}

\begin{figure}[H]
  \centering
  \includegraphics[width=10cm]{fig/CPU_decode.png}
  \caption{译码逻辑设计}
  \label{fig:CPU_decode}
\end{figure}

译码逻辑的代码见图\ref{fig:CPU_decode}。主要的任务是：

a. 从inst中分离出opcode, rs, rt, rd, shamt和func几个主要部分。

b. 根据opcode识别出主要的值令类型，并通过IS\_RTYPE等一系列wire记录。

c. 进一步根据TYPE和func的部分位数，识别值令的子类型，并通过IS\_R\_CalType等wire记录。

d. 处理特殊值令：单独识别一些重复出现的，部分译码信号与大多数值令不同的特殊值令，如jal等。

e. 解码得到通用的操作数，包括RF\_raddr, src, imm等。

这样\textbf{按照值值令格式和值令类型设置译码逻辑}，可以很大程度地减少重复的布线，易于设计维护，提高运行效率并减少综合面积等等。

3. \textbf{模块与译码信号的连接}

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{fig/CPU_connect_1.png}
  \end{minipage}%
  \hspace{5pt}
  \begin{minipage}[b]{0.3\linewidth}
    \includegraphics[width=\linewidth]{fig/CPU_connect_2.png}
  \end{minipage}
  \caption{模块连接}
  \label{fig:CPU_connect}
\end{figure}

模块连接部分的代码见图\ref{fig:CPU_connect}。根据译码表中的信息，通过assign语句进行赋值即可。

4. \textbf{更新PC的时序逻辑设计}

\begin{figure}[H]
  \centering
  \includegraphics[width=8cm]{fig/CPU_pc.png}
  \caption{PC时序逻辑}
\end{figure}

定义静态下一PC为PC+4， 记为snpc(Static next PC)。下一时刻更新的PC可能包括snpc, snpc+imm, 或者覆盖为\{pcReg[31:28], imm26, 2'b00\}或src1四种可能，因此用2位的pcOp编码，其中高位表示是覆盖还是累加，第一位表示覆盖或者累加的选择。这样编码可以保证\textbf{赋值条件互斥}，综合出两个加法器，满足图\ref{fig:CPU_circuit}的设计。

此外，在always block中设置同步的复位信号，保证了\textbf{复位信号的使用}

\section{实验过程中遇到的问题、对问题的思考过程及解决方法}

\noindent
$\bullet$
\textbf{移位器设计问题}。

移位器的设计中并未遇到问题

\vspace{1ex}

\noindent
$\bullet$
\textbf{CPU设计问题}。

1. \textbf{译码信号的化简}

在第一部分列出的译码表中，-代表信号可以随意输入，原因解释如下：

CPU(和内存)中的组建可以分为两类，一类是会保存状态到下一个时钟周期的，如寄存器，PC，内存；另外一类是数据会在下一个时钟周期被覆盖的，如ALU，Shifter等等。对于后者，随意出入当前值令不需要的信号是安全的，因为它一定不会影响到下一个时钟周期机器运行的状态。但是对于前者就需要格外小心，因为随意输入的信号造成的影响有可能被保存到之后的时钟周期，从而造成Undefined Behavior

实际上，要解决这个问题也很简单：第一类器件都有相应的enable信号，所以只要这却设置了每一条值令的enable信号，就能保证其他-信号位置输入无意义信号时产生的状态不被保存。

综合上述分析，\textbf{只有各个器件的enable信号是需要按照值令严格设置的(这也是对应列被标红的原因)，其他位置的-信号就可以进行随意的化简}。一个化简的基本原则是找出最大的公共因子赋值，比如raddr1直接赋值为rs，raddr2赋值为rt


2. \textbf{memWrite值令的优化技巧}

sb和sw值令要求根据地址最后两位的偏移正确地设置wData的部分字节。\textbf{但是MIPS值令手册并没有规定剩余的字节需要如何设置}。这意味着\textbf{可以通过填入相同的内容来简化指令的处理}（比如sb值令就填入四个相同的字节，sw值令就填入两个相同的双字节），这样无论指令要求写入的是哪个位置，都可以邦正写入正确的数据

3. \textbf{调试过程中的问题}

在实现代码的时候，由于电路较为复杂，时常会在一些细节上犯错（比如打错了指令的子类型，lwl,lwr等非对齐指令的字节序不小心写反了等等）。但是由于实验的基础设施十分完善，不光提供错的波形输出，还\textbf{实现了Difftest功能}，让有error行为的地方能即时地以failure的形式被报告，使得调试的过程十分顺利，并没有遇见大的困难。

\section{对讲义中思考题（如有）的理解和回答}

1. \textbf{ALUop的编码有什么规律？表格中的ALUop编码是否还有优化空间？}

记从左到右依次为第2,1,0位，可能的编码规律为：

$\bullet$若第1位为0,则为逻辑操作，第2位与第0位组合形成00, 01, 10, 11选择4种操作

$\bullet$若第1位为1

\hspace*{0.5cm}$\bullet$若第0位为0, 则为算术运算，根据第2位选择+或者-

\hspace*{0.5cm}$\bullet$若第0位为1, 则为移位运算，根据第2位选择有符号或者无符号

我认为设计已经比较合理，优化空间有限

\section{收获与感想}

通过本次实验，我对MIPS处理器设计有了更深入的理解。译码逻辑的模块化设计实践，特别是通过指令格式共性提取公共译码信号的方法，显著提升了代码复用率与可维护性。再一开始的时候，我虽然做了指令的译码表，但是并没有在rtl的设计上将译码的部分独立出来，而是直接与其他模块的连接相耦合。在与助教交流之后，我将其解耦，并体会到了这样写的好处。

调试过程中，通过enable信号精确控制状态更新的经验，使我更加理解时序电路中数据有效性的管理机制。实验平台提供的Difftest工具极大提升了验证效率，这种自动化测试方法对复杂系统开发具有重要借鉴意义。

本次设计也让我体会到理论知识与工程实践的差异：指令集中未明确定义的行为（如非对齐存储）需要通过合理假设进行简化实现，这对硬件设计的可行性至关重要。

\section{实验所耗时间}

\newcommand{\labTime}{6} % 请在这里填写实验所耗时间（单位：小时）

在课后，你花费了大约\underline{\makebox[5em][c]{\labTime}}小时完成此次实验。

\end{document}